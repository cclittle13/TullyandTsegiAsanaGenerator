Skills #1

"""Skills Assessment: Lists
Edit the function bodies until all of the doctests pass when you run this file.
"""


def all_odd(number_list):
    """Return a list of only the odd numbers in the input list.
        >>> all_odd([1, 2, 7, -5])
        [1, 7, -5]
        >>> all_odd([2, -6, 8])
        []
    """

    return [num for num in number_list if num % 2 == 1]


def all_even(number_list):
    """Return a list of only the even numbers in the input list.
        >>> all_even([2, 6, -1, -2])
        [2, 6, -2]
        >>> all_even([-1, 3, 5])
        []
    """

    return [num for num in number_list if num % 2 == 0]


def print_indexes(my_list):
    """Print the index of each item in the input_list, followed by the item itself.
    Do this without using a counting variable---that is, don't do something
    like this:
        count = 0
        for item in list:
            print count
            count = count + 1
    Output should look like this:
        >>> print_indexes(["Toyota", "Jeep", "Volvo"])
        0 Toyota
        1 Jeep
        2 Volvo
    """

    # Note on solution: Because enumerate was suggested in further reading
    # durring lecutre, I hope it is ok to use.  It makes a list of tuples, then
    # my understanding is that the "item, index" part of the for loop unpacks
    # those so we can use both durring itteration.

    for index, item in enumerate(my_list):
        print "{} {}".format(index, item)


def long_words(word_list):
    """Return all words in input list that are longer than 4 characters.
        >>> long_words(["hello", "hey", "spam", "spam", "bacon", "bacon"])
        ['hello', 'bacon', 'bacon']
        >>> long_words(["all", "are", "tiny"])
        []
    """

    return [word for word in word_list if len(word) > 4]


def smallest_int(number_list):
    """Find the smallest integer in a list of integers and return it.
    DO NOT USE the built-in function `min`!
        >>> smallest_int([-5, 2, -5, 7])
        -5
        >>> smallest_int([3, 7, 2, 8, 4])
        2
    If the input list is empty, return None:
        >>> smallest_int([]) is None
        True
    """

    # Notes on solution:
    #
    # For the empty list I return None explicitly just to be clear, however a
    # return statement alone would accomplish the same thing.
    #
    # An alternate solution would be to assign min_num to None in the empty list
    # branch and then return min_num outside the if/else blocks.
    #
    # The comparison of num to min_num is unnecesary on the first iteration,
    # since they are the same number.  However, my potential rewrites
    # using range() and indexing to avoid this extra step were less clear to
    # read, so I left it as it.

    if len(number_list) == 0:
        return None
    else:
        min_num = number_list[0]
        for num in number_list:
            if min_num > num:
                min_num = num
        return min_num


def largest_int(number_list):
    """Find the largest integer in a list of integers and return it.
    DO NOT USE the built-in function `max`!
        >>> largest_int([-5, 2, -5, 7])
        7
        >>> largest_int([3, 7, 2, 8, 4])
        8
    If the input list is empty, return None:
        >>> largest_int([]) is None
        True
    """

    # Here I have made the alternate design decision for return of None via the
    # same return statement outside the loop.  (see note above in smallest_int)

    if len(number_list) == 0:
        max_num = None
    else:
        max_num = number_list[0]
        for num in number_list:
            if max_num < num:
                max_num = num

    return max_num


def halvesies(number_list):
    """Return list of numbers from input list, each divided by two.
        >>> halvesies([2, 6, -2])
        [1.0, 3.0, -1.0]
    If any of the numbers are odd, make sure you don't round off the half:
        >>> halvesies([1, 5])
        [0.5, 2.5]
    """

    return [float(num)/2 for num in number_list]


def word_lengths(word_list):
    """Return the length of words in the input list.
        >>> word_lengths(["hello", "hey", "hello", "spam"])
        [5, 3, 5, 4]
    """

    return [len(word) for word in word_list]


def sum_numbers(number_list):
    """Return the sum of all of the numbers in the list.
    Python has a built-in function, `sum()`, which already does this -- but for
    this exercise, you should not use it.
        >>> sum_numbers([1, 2, 3, 10])
        16
    Any empty list should return the sum of zero:
        >>> sum_numbers([])
        0
    """

    # This initializes the sum and is also the default value for empty list,
    # in which case the loop below will simply do nothing
    sum_of_nums = 0

    for num in number_list:
        sum_of_nums += num

    return sum_of_nums


def mult_numbers(number_list):
    """Return product (result of multiplication) of the numbers in the list.
        >>> mult_numbers([1, 2, 3])
        6
    Obviously, if there is a zero in the input, the product will be zero:
        >>> mult_numbers([10, 20, 0, 50])
        0
    As explained at http://en.wikipedia.org/wiki/Empty_product, if the list is
    empty, the product should be 1:
        >>> mult_numbers([])
        1
    """

    # This initializes the product with the identity, which is also the default
    # output for the empty list in which case the loop below will do nothing
    product = 1

    for num in number_list:
        product = product * num

    return product


def join_strings(word_list):
    """Return a string of all input strings joined together.
    Python has a built-in method on lists, `join`---but for this exercise, you
    should not use it.
        >>> join_strings(["spam", "spam", "bacon", "balloonicorn"])
        'spamspambaconballoonicorn'
    For an empty list, you should return an empty string:
        >>> join_strings([])
        ''
    """

    # Note that on each loop below the name joined_string will be bound to a
    # differnt location because of string immutability.  I suspect that the
    # built-in function might do somethign more graceful or efficient.

    joined_string = ''
    for word in word_list:
        joined_string = joined_string + word

    return joined_string


def average(number_list):
    """Return the average (mean) of the list of numbers given.
        >>> average([2, 12, 3])
        5.666666666666667
    There is no defined answer if the list given is empty. It's fine if
    this raises an error when given an empty list.
    """

    # The first step is to calculate the sum as previously
    sum_of_nums = 0
    for num in number_list:
        sum_of_nums += num

    # Division must be done after conversion to float to avoid integer division
    # rounding.  Also, this will produce an error if the length is 0.  I tested
    # this by adding ">>> average([])" to the doctests and observed the error,
    # but did not know how to actually write a test for the error output.
    ave = float(sum_of_nums) / len(number_list)

    return ave


def join_strings_with_comma(list_of_words):
    """Return ['list', 'of', 'words'] like "list, of, words".
        >>> join_strings_with_comma(["Labrador", "Poodle", "French Bulldog"])
        'Labrador, Poodle, French Bulldog'
    If there's only one thing in the list, it should return just that
    thing, of course:
        >>> join_strings_with_comma(["Pretzel"])
        'Pretzel'
    """

    # Note:  Make this easier to read or understand

    joined_string = ""
    while len(list_of_words) > 0:
        joined_string = joined_string + list_of_words.pop(0)
        if len(list_of_words) > 0:
            joined_string = joined_string + ", "

    return joined_string


##############################################################################
# END OF ASSIGNMENT: You can ignore everything below.


if __name__ == "__main__":
    import doctest
    print
    result = doctest.testmod()
    if not result.failed:
        print "*** %s TESTS PASSED. GOOD WORK!" % result.attempted
    print



    Skills #2 


    """Skills-dictionaries.
      IMPORTANT: these problems are meant to be solved using dictionaries and sets.
    """


    def without_duplicates(words):
        """Given a list of words, return the list with duplicates removed.
        For example:
            >>> sorted(without_duplicates(
            ...     ["rose", "is", "a", "rose", "is", "a", "rose"]))
            ['a', 'is', 'rose']
        You should treat differently-capitalized words as different:
            >>> sorted(without_duplicates(
            ...     ["Rose", "is", "a", "rose", "is", "a", "rose"]))
            ['Rose', 'a', 'is', 'rose']
        """

        return list(set(words))


    def find_unique_common_items(list1, list2):
        """Produce the set of *unique* common items in two lists.
        Given two lists, return a list of the *unique* common items shared between
        the lists.
        IMPORTANT: you may not use 'if ___ in ___' or the method 'index'.
        This should find [1, 2]:
            >>> sorted(find_unique_common_items([1, 2, 3, 4], [2, 1]))
            [1, 2]
        However, now we only want unique items, so for these lists, don't show
        more than 1 or 2 once:
            >>> sorted(find_unique_common_items([4, 3, 2, 1], [1, 1, 2, 2]))
            [1, 2]
        """
        # The union of the sets will be the common items, sets are inherently
        # unique.

        unique_common_items = set(list1) & set(list2)
        return list(unique_common_items)


    def count_unique(input_string):
        """Count unique words in a string.
        This function should take a single string and return a dictionary
        that has all of the distinct words as keys, and the number of times
        that word appears in the string as values.
        For example:
            >>> print_dict(count_unique("each word appears once"))
            {'appears': 1, 'each': 1, 'once': 1, 'word': 1}
        Words that appear more than once should be counted each time:
            >>> print_dict(count_unique("rose is a rose is a rose"))
            {'a': 2, 'is': 2, 'rose': 3}
        It's fine to consider punctuation part of a word (e.g., a comma
        at the end of a word can be counted as part of that word) and
        to consider differently-capitalized words as different:
            >>> print_dict(count_unique("Porcupine see, porcupine do."))
            {'Porcupine': 1, 'do.': 1, 'porcupine': 1, 'see,': 1}
        """

        # Initialize dictionary to use and get words seperated by whitespace
        word_count = {}
        words = input_string.split()

        # For each word, add to dictionary if it's not there, update word count for
        # the dict key word.
        for word in words:
            if word not in word_count:
                word_count[word] = 0
            word_count[word] += 1

        return word_count


    def translate_to_pirate_talk(phrase):
        """Translate phrase to pirate talk.
        Given a phrase, translate each word to the Pirate-speak equivalent.
        Words that cannot be translated into Pirate-speak should pass through
        unchanged. Return the resulting sentence.
        Here's a table of English to Pirate translations:
        English     Pirate
        ----------  ----------------
        sir         matey
        hotel       fleabag inn
        student     swabbie
        boy         matey
        madam       proud beauty
        professor   foul blaggart
        restaurant  galley
        your        yer
        excuse      arr
        students    swabbies
        are         be
        lawyer      foul blaggart
        the         th'
        restroom    head
        my          me
        hello       avast
        is          be
        man         matey
        For example:
            >>> translate_to_pirate_talk("my student is not a man")
            'me swabbie be not a matey'
        You should treat words with punctuation as if they were different
        words:
            >>> translate_to_pirate_talk("my student is not a man!")
            'me swabbie be not a man!'
        """

        # If the number of translations were much greater, it could makes senese to
        # parse them in from a seperate file. However, I simply placed them in
        # another file and used a few quick and dirty replace commands to make the
        # dictionary input.

        pirate_translation = {
            "sir": "matey",
            "hotel": "fleabag inn",
            "student": "swabbie",
            "boy": "matey",
            "madam": "proud beauty",
            "professor": "foul blaggart",
            "restaurant": "galley",
            "your": "yer",
            "excuse": "arr",
            "students": "swabbies",
            "are": "be",
            "lawyer": "foul blaggart",
            "the": "th'",
            "restroom": "head",
            "my": "me",
            "hello": "avast",
            "is": "be",
            "man": "matey",
        }

        # Separate the phrase to be translated into a list of words, for each word
        # replace with the translation if in the dictionay, otherwise just put back
        # the origional word.

        phrase = phrase.split()
        for idx, word in enumerate(phrase):
            phrase[idx] = pirate_translation.get(word, word)

        return " ".join(phrase)


    def sort_by_word_length(words):
        """Given list of words, return list of ascending [(len, [words])].
        Given a list of words, return a list of tuples, ordered by word-length.
        Each tuple should have two items---the length of the words for that
        word-length, and the list of words of that word length.
        For example:
            >>> sort_by_word_length(["ok", "an", "apple", "a", "day"])
            [(1, ['a']), (2, ['ok', 'an']), (3, ['day']), (5, ['apple'])]
        """

        words_by_length = {}

        for word in words:
            word_length = len(word)
            if word_length not in words_by_length:
                words_by_length[word_length] = []
            words_by_length[word_length].append(word)

        return sorted(words_by_length.items())


    def get_sum_zero_pairs(input_list):
        """Given list of numbers, return list of pair summing to 0.
        Given a list of numbers, add up each individual pair of numbers.
        Return a list of each pair of numbers that adds up to 0.
        For example:
            >>> sort_pairs( get_sum_zero_pairs([1, 2, 3, -2, -1]) )
            [[-2, 2], [-1, 1]]
            >>> sort_pairs( get_sum_zero_pairs([3, -3, 2, 1, -2, -1]) )
            [[-3, 3], [-2, 2], [-1, 1]]
        This should always be a unique list, even if there are
        duplicates in the input list:
            >>> sort_pairs( get_sum_zero_pairs([1, 2, 3, -2, -1, 1, 1]) )
            [[-2, 2], [-1, 1]]
        Of course, if there are one or more zeros to pair together,
        that's fine, too (even a single zero can pair with itself):
            >>> sort_pairs( get_sum_zero_pairs([1, 2, 3, -2, -1, 1, 1, 0]) )
            [[-2, 2], [-1, 1], [0, 0]]
        """

        # This solution uses a set, and tuples of numbers, because that seems to me
        # to be most conceptually consistant with what is being asked for.
        #
        # Loop thorugh items in list, and for each loop through the subsequent items
        # in the list chekcing the sum.  The items precceding and item have already
        # been checked.  Becuase of the zero case, include the item iteself in the
        # neested part of the for loop.
        zero_sum_pairs = set()
        for idx, num1 in enumerate(input_list):
            for num2 in input_list[idx:]:
                if (num1 + num2) == 0:
                    if num1 < num2:
                        zero_sum_pairs.add((num1, num2))
                    else:
                        zero_sum_pairs.add((num2, num1))

        # Look! and incomprehensible list comprehension that does the same thing!
        # (I know this is confusing and thus bad style, but it was fun to write)
        #
        # zero_sum_pairs = set([tuple(sorted([num1, num2]))
        #                       for idx, num1 in enumerate(input_list)
        #                       for num2 in input_list[idx:] if (num1 + num2) == 0])

        # Note that there were ways to solve this with a dictionary, where
        # uniqueness is essentially checked via uniqueness of keys.  In most of
        # those cases there wasn't something that made sense to store as a value,
        # or doing so made the program more confusing, so I just used sets.

        # Also, I'm cheating a bit by outputting tuples here since they are immutable
        # for either dict keys or set use, and the tests use sorted() which converts
        # to a list anyway. If we care about that type output we could loop through
        # converting to lists.

        return list(zero_sum_pairs)


    ##############################################################################
    # You can ignore everything below this.

    def print_dict(d):
        # This method is just used to print dictionaries in key-alphabetical
        # order, and is only used for our documentation tests. You can ignore it.
        if isinstance(d, dict):
            print "{" + ", ".join("%r: %r" % (k, d[k]) for k in sorted(d)) + "}"
        else:
            print d


    def sort_pairs(l):
        # Print sorted list of pairs where the pairs are sorted. This is used only
        # for documentation tests. You can ignore it.
        return sorted(sorted(pair) for pair in l)


    if __name__ == "__main__":
        print
        import doctest
        if doctest.testmod().failed == 0:
            print "*** ALL TESTS PASSED ***"
        print
